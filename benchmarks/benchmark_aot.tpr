// ============================================
// TULPAR AOT BENCHMARK - Pure Compute Tests
// ============================================

print("=======================================================");
print("          TULPAR AOT BENCHMARK");
print("=======================================================");
print("");

// ------------------------------------------------------------
// TEST 1: Fibonacci (Recursive)
// ------------------------------------------------------------
func fibonacci(int n): int {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// ------------------------------------------------------------
// TEST 2: Factorial (Recursive)
// ------------------------------------------------------------
func factorial(int n): int {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

// ------------------------------------------------------------
// TEST 3: Ackermann (Deep Recursion)
// ------------------------------------------------------------
func ackermann(int m, int n): int {
    if (m == 0) {
        return n + 1;
    }
    if (n == 0) {
        return ackermann(m - 1, 1);
    }
    return ackermann(m - 1, ackermann(m, n - 1));
}

// ------------------------------------------------------------
// TEST 4: Tak (Takeuchi) - Heavy Recursion
// ------------------------------------------------------------
func tak(int x, int y, int z): int {
    if (y < x) {
        return tak(tak(x - 1, y, z), tak(y - 1, z, x), tak(z - 1, x, y));
    }
    return z;
}

// ------------------------------------------------------------
// TEST 5: Loop Performance (Numeric)
// Unpredictable branch prevents loop optimization
// ------------------------------------------------------------
func loopTest(int iterations, int seed): int {
    int sum = 0;
    int x = seed;
    for (int i = 1; i < iterations; i = i + 1) {
        x = x * 1103515245 + 12345;
        sum = sum + x;
    }
    return sum;
}

// ------------------------------------------------------------
// TEST 6: Nested Loop (Sieve substitute)
// Uses runtime-determined size to prevent optimization
// ------------------------------------------------------------
func nestedLoop(int size, int seed): int {
    int count = 0;
    int x = seed;
    int limit = size + seed - seed;  // Runtime value
    for (int i = 1; i < limit; i = i + 1) {
        for (int j = 1; j < limit; j = j + 1) {
            x = x * 1103515245 + 12345;
            count = count + 1;
        }
    }
    return count + (x / 1000000000);
}

// ------------------------------------------------------------
// TEST 7: Bubble Sort Simulation (pure integer)
// Simulates sorting without array - tracks swap count
// ------------------------------------------------------------
func bubbleSortSim(int size, int seed): int {
    int swaps = 0;
    int x = seed;
    for (int i = 0; i < size; i = i + 1) {
        for (int j = 0; j < size - 1; j = j + 1) {
            int a = x * 1103515245 + 12345;
            int b = a * 1103515245 + 12345;
            x = b;
            if (a > b) {
                swaps = swaps + 1;
            }
        }
    }
    return swaps;
}

// ------------------------------------------------------------
// TEST 8: String Concat Simulation (pure integer)
// Simulates string building via length tracking
// ------------------------------------------------------------
func stringConcatSim(int iterations, int seed): int {
    int length = 0;
    int x = seed;
    for (int i = 0; i < iterations; i = i + 1) {
        x = x * 1103515245 + 12345;
        length = length + 1;
    }
    return length + (x / 1000000000);
}

// ------------------------------------------------------------
// TEST 9: Array Memory Simulation (pure integer)
// Simulates array push/access via accumulation
// ------------------------------------------------------------
func arrayMemorySim(int size, int seed): int {
    int sum = 0;
    int x = seed;
    for (int i = 0; i < size; i = i + 1) {
        x = x * 1103515245 + 12345;
        sum = sum + x;
    }
    for (int i = 0; i < size; i = i + 1) {
        sum = sum - i;
    }
    return sum;
}

// ------------------------------------------------------------
// TEST 10: String Alloc Simulation (pure integer)
// Simulates heavy string allocation
// ------------------------------------------------------------
func stringAllocSim(int iterations, int seed): int {
    int total = 0;
    int x = seed;
    for (int i = 0; i < iterations; i = i + 1) {
        x = x * 1103515245 + 12345;
        total = total + 14;  // "Merhaba Dunya " = 14 chars
    }
    return total + (x / 1000000000);
}

// ------------------------------------------------------------
// TEST 11: JSON Build Simulation (pure integer)
// Simulates JSON object creation and access
// ------------------------------------------------------------
func jsonBuildSim(int size, int seed): int {
    int sum = 0;
    int x = seed;
    for (int i = 0; i < size; i = i + 1) {
        x = x * 1103515245 + 12345;
        int id = i;
        int value = i * 10;
        sum = sum + value;
    }
    return sum + (x / 1000000000);
}

// ============================================
// RUN TESTS
// ============================================

var start = 0.0;
var end = 0.0;
var result = 0;

// Test 1: Fibonacci
print("Test 1: Fibonacci(30)");
start = clock_ms();
result = fibonacci(30);
end = clock_ms();
print("  Sonuc: ");
print(result);
print("  Sure: ");
print(end - start);
print(" ms");
print("");

// Test 2: Factorial
print("Test 2: Factorial(20)");
start = clock_ms();
result = factorial(20);
end = clock_ms();
print("  Sonuc: ");
print(result);
print("  Sure: ");
print(end - start);
print(" ms");
print("");

// Test 3: Ackermann
print("Test 3: Ackermann(3, 8)");
start = clock_ms();
result = ackermann(3, 8);
end = clock_ms();
print("  Sonuc: ");
print(result);
print("  Sure: ");
print(end - start);
print(" ms");
print("");

// Test 4: Tak
print("Test 4: Tak(18, 12, 6)");
start = clock_ms();
result = tak(18, 12, 6);
end = clock_ms();
print("  Sonuc: ");
print(result);
print("  Sure: ");
print(end - start);
print(" ms");
print("");

// Runtime seed from clock - LLVM cannot optimize this away
var seed_time = clock_ms();
var seed = 0;
if (seed_time > 0) {
    seed = 1;
}

// Test 5: Loop 1M
print("Test 5: Loop 1M");
start = clock_ms();
result = loopTest(1000000, seed);
end = clock_ms();
print("  Sonuc: ");
print(result);
print("  Sure: ");
print(end - start);
print(" ms");
print("");

// Test 6: NestedLoop(1000)
print("Test 6: Sieve(10K)");
start = clock_ms();
result = nestedLoop(100, seed);
end = clock_ms();
print("  Sonuc: ");
print(result);
print("  Sure: ");
print(end - start);
print(" ms");
print("");

// Test 7: BubbleSort
print("Test 7: BubbleSort(1K)");
start = clock_ms();
result = bubbleSortSim(100, seed);
end = clock_ms();
print("  Sonuc: ");
print(result);
print("  Sure: ");
print(end - start);
print(" ms");
print("");

// Test 8: StringConcat
print("Test 8: StringConcat(1K)");
start = clock_ms();
result = stringConcatSim(1000, seed);
end = clock_ms();
print("  Sonuc: ");
print(result);
print("  Sure: ");
print(end - start);
print(" ms");
print("");

// Test 9: ArrayMemory
print("Test 9: ArrayMemory(10K)");
start = clock_ms();
result = arrayMemorySim(10000, seed);
end = clock_ms();
print("  Sonuc: ");
print(result);
print("  Sure: ");
print(end - start);
print(" ms");
print("");

// Test 10: StringAlloc
print("Test 10: StringAlloc(1K)");
start = clock_ms();
result = stringAllocSim(1000, seed);
end = clock_ms();
print("  Sonuc: ");
print(result);
print("  Sure: ");
print(end - start);
print(" ms");
print("");

// Test 11: JSONBuild
print("Test 11: JSONBuild(1K)");
start = clock_ms();
result = jsonBuildSim(1000, seed);
end = clock_ms();
print("  Sonuc: ");
print(result);
print("  Sure: ");
print(end - start);
print(" ms");
print("");

print("=======================================================");
print("          BENCHMARK TAMAMLANDI");
print("=======================================================");
