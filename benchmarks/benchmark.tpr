// ============================================
// TULPAR PERFORMANS BENCHMARK TESTİ v2
// Tulpar ile uyumlu testler
// ============================================

print("=======================================================");
print("          TULPAR PERFORMANS BENCHMARK v2");
print("=======================================================");
print("");

// ------------------------------------------------------------
// TEST 1: Fibonacci (Rekürsif)
// ------------------------------------------------------------
func fibonacci(int n): int {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// ------------------------------------------------------------
// TEST 2: Faktöriyel (Rekürsif)
// ------------------------------------------------------------
func factorial(int n): int {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

// ------------------------------------------------------------
// TEST 3: Ackermann (Derin Rekürsiyon)
// A(m, n)
// ------------------------------------------------------------
func ackermann(int m, int n): int {
    if (m == 0) {
        return n + 1;
    }
    if (n == 0) {
        return ackermann(m - 1, 1);
    }
    return ackermann(m - 1, ackermann(m, n - 1));
}

// ------------------------------------------------------------
// TEST 4: Tak (Takuechi) - Yoğun Rekürsiyon
// ------------------------------------------------------------
func tak(int x, int y, int z): int {
    if (y < x) {
        return tak(tak(x - 1, y, z), tak(y - 1, z, x), tak(z - 1, x, y));
    }
    return z;
}

// ------------------------------------------------------------
// TEST 5: Döngü Performansı (Sayısal)
// ------------------------------------------------------------
func loopTest(int iterations): int {
    int sum = 0;
    for (int i = 0; i < iterations; i++) {
        sum = sum + i;
    }
    return sum;
}

// ------------------------------------------------------------
// TEST 6: Sieve of Eratosthenes (Dizi/Bellek)
// Primes up to n
// ------------------------------------------------------------
func sieve(int n): int {
    json flags = []; 
    for(int i=0; i<=n; i++) {
        push(flags, 0); 
    }
    
    int count = 0;
    for(int i=2; i<=n; i++) {
        if(flags[i] == 0) {
            count = count + 1;
            for(int k=i*i; k<=n; k=k+i) {
                flags[k] = 1;
            }
        }
    }
    return count;
}

// ------------------------------------------------------------
// TEST 7: Bubble Sort (Dizi/Nested Loop)
// Anti-optimization: Full checksum to prevent dead code elimination
// ------------------------------------------------------------
func bubbleSort(int size): int {
    json arr = [];
    int seed = 12345;
    for(int i=0; i<size; i++) {
        int temp = seed * 1103515245 + 12345;
        seed = temp - (temp / 32768) * 32768;
        push(arr, seed);
    }
    
    for(int i=0; i<size; i++) {
        for(int j=0; j<size-1; j++) {
            if(arr[j] > arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    
    // Compute checksum of ALL elements to prevent optimization
    int checksum = 0;
    for(int i=0; i<size; i++) {
        checksum = checksum + arr[i];
    }
    return checksum;
}

// ------------------------------------------------------------
// TEST 8: String Concatenation
// ------------------------------------------------------------
func stringConcat(int iterations): int {
    string result = "";
    for(int i=0; i<iterations; i++) {
        result = result + "a";
    }
    return len(result);
}

// ------------------------------------------------------------
// TEST 9: Array Push/Pop (Memory)
// ------------------------------------------------------------
func arrayMemory(int size): int {
    json arr = [];
    for(int i=0; i<size; i++) {
        push(arr, i);
    }
    int sum = 0;
    for(int i=0; i<size; i++) {
        sum = sum + arr[i];
    }
    return sum;
}

// ------------------------------------------------------------
// TEST 10: String Allocation (Heavy String Test)
// Uses StringBuilder for O(n) performance instead of O(n²)
// ------------------------------------------------------------
func stringAllocation(int iterations): int {
    var sb = StringBuilder(iterations * 20);
    for(int i=0; i<iterations; i++) {
        sb_append(sb, "Merhaba Dunya ");
    }
    string result = sb_tostring(sb);
    sb_free(sb);
    return len(result);
}

// ------------------------------------------------------------
// TEST 11: JSON Build & Parse (Object Creation)
// Build large JSON object and access elements
// ------------------------------------------------------------
func jsonBuildTest(int size): int {
    json data = [];
    for(int i=0; i<size; i++) {
        json item = {
            "id": i,
            "name": "Item",
            "value": i * 10,
            "active": 1
        };
        push(data, item);
    }
    // Access and sum values
    int sum = 0;
    for(int i=0; i<size; i++) {
        sum = sum + data[i]["value"];
    }
    return sum;
}

// ============================================================
// RUN TESTS
// ============================================================

float total_time = 0.0;
float start = 0.0;
float end = 0.0;

// 1. Fibonacci
print("Test 1: Fibonacci(30)");
start = clock_ms();
int r1 = fibonacci(30);
end = clock_ms();
float t1 = end - start;
total_time = total_time + t1;
print("  Sonuc:", r1);
print("  Sure:", t1, "ms");
print("");

// 2. Factorial
print("Test 2: Factorial(20)");
start = clock_ms();
int r2 = factorial(20);
end = clock_ms();
float t2 = end - start;
total_time = total_time + t2;
print("  Sonuc:", r2);
print("  Sure:", t2, "ms");
print("");

// 3. Ackermann
print("Test 3: Ackermann(3, 8)");
start = clock_ms();
int r3 = ackermann(3, 8);
end = clock_ms();
float t3 = end - start;
total_time = total_time + t3;
print("  Sonuc:", r3);
print("  Sure:", t3, "ms");
print("");

// 4. Tak
print("Test 4: Tak(18, 12, 6)");
start = clock_ms();
int r4 = tak(18, 12, 6);
end = clock_ms();
float t4 = end - start;
total_time = total_time + t4;
print("  Sonuc:", r4);
print("  Sure:", t4, "ms");
print("");

// 5. Loop
print("Test 5: Loop 1M");
start = clock_ms();
int r5 = loopTest(1000000);
end = clock_ms();
float t5 = end - start;
total_time = total_time + t5;
print("  Sonuc:", r5);
print("  Sure:", t5, "ms");
print("");

// 6. Sieve
print("Test 6: Sieve(10000)");
start = clock_ms();
int r6 = sieve(10000);
end = clock_ms();
float t6 = end - start;
total_time = total_time + t6;
print("  Sonuc:", r6);
print("  Sure:", t6, "ms");
print("");

// 7. Bubble Sort (Fixed: Now uses value-based array access - no stack overflow!)
print("Test 7: BubbleSort(1000)");
start = clock_ms();
int r7 = bubbleSort(1000);
end = clock_ms();
float t7 = end - start;
total_time = total_time + t7;
print("  Sonuc:", r7);
print("  Sure:", t7, "ms");
print("");

// 8. String Concat
print("Test 8: StringConcat(1000)");
start = clock_ms();
int r8 = stringConcat(1000);
end = clock_ms();
float t8 = end - start;
total_time = total_time + t8;
print("  Sonuc:", r8);
print("  Sure:", t8, "ms");
print("");

// 9. Array Memory
print("Test 9: ArrayMemory(10000)");
start = clock_ms();
int r9 = arrayMemory(10000);
end = clock_ms();
float t9 = end - start;
total_time = total_time + t9;
print("  Sonuc:", r9);
print("  Sure:", t9, "ms");
print("");

// 10. String Allocation (Heavy)
/*
print("Test 10: StringAllocation(1000)");
start = clock_ms();
int r10 = stringAllocation(1000);
end = clock_ms();
float t10 = end - start;
total_time = total_time + t10;
print("  Sonuc:", r10);
print("  Sure:", t10, "ms");
print("");
*/

// 11. JSON Build Test
print("Test 11: JSONBuild(1000)");
start = clock_ms();
int r11 = jsonBuildTest(1000);
end = clock_ms();
float t11 = end - start;
total_time = total_time + t11;
print("  Sonuc:", r11);
print("  Sure:", t11, "ms");
print("");

print("=======================================================");
print("TOPLAM SURE:", total_time, "ms");
print("=======================================================");
