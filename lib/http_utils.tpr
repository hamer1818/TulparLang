// ============================================
// Tulpar HTTP Utilities Library
// Cookies, Sessions, Static Files, HTTP Parsing
// ============================================

// ============================================
// HTTP Request/Response Functions
// ============================================

// HTTP Request Parse Et
// "GET /path HTTP/1.1\r\nHeader: value\r\n\r\nbody"
func http_parse_request(str raw_request) {
    json result = {
        "method": "",
        "path": "",
        "version": "",
        "headers": {},
        "body": ""
    };
    
    if (length(raw_request) == 0) {
        return result;
    }
    
    // Headers ve body ayır
    int body_start = indexOf(raw_request, "\r\n\r\n");
    str headers_part = raw_request;
    str body_part = "";
    
    if (body_start >= 0) {
        headers_part = substring(raw_request, 0, body_start);
        body_part = substring(raw_request, body_start + 4, length(raw_request));
    }
    
    // İlk satır: GET /path HTTP/1.1
    array lines = split(headers_part, "\r\n");
    
    if (length(lines) > 0) {
        str first_line = lines[0];
        array parts = split(first_line, " ");
        
        if (length(parts) >= 2) {
            result["method"] = parts[0];
            result["path"] = parts[1];
            if (length(parts) >= 3) {
                result["version"] = parts[2];
            }
        }
    }
    
    // Headers parse et
    json headers = {};
    for (int i = 1; i < length(lines); i++) {
        str line = lines[i];
        int colon = indexOf(line, ":");
        if (colon > 0) {
            str key = substring(line, 0, colon);
            str value = substring(line, colon + 1, length(line));
            // Trim leading space from value
            if (length(value) > 0 && value[0] == " ") {
                value = substring(value, 1, length(value));
            }
            headers[key] = value;
        }
    }
    result["headers"] = headers;
    
    // Body
    result["body"] = body_part;
    
    return result;
}

// HTTP Response Oluştur
func http_create_response(int status, str content_type, str body) {
    str status_text = "OK";
    if (status == 201) { status_text = "Created"; }
    if (status == 204) { status_text = "No Content"; }
    if (status == 301) { status_text = "Moved Permanently"; }
    if (status == 302) { status_text = "Found"; }
    if (status == 304) { status_text = "Not Modified"; }
    if (status == 400) { status_text = "Bad Request"; }
    if (status == 401) { status_text = "Unauthorized"; }
    if (status == 403) { status_text = "Forbidden"; }
    if (status == 404) { status_text = "Not Found"; }
    if (status == 405) { status_text = "Method Not Allowed"; }
    if (status == 500) { status_text = "Internal Server Error"; }
    if (status == 501) { status_text = "Not Implemented"; }
    if (status == 503) { status_text = "Service Unavailable"; }
    
    str response = "HTTP/1.1 " + toString(status) + " " + status_text + "\r\n";
    response = response + "Content-Type: " + content_type + "\r\n";
    response = response + "Content-Length: " + toString(length(body)) + "\r\n";
    response = response + "Connection: close\r\n";
    response = response + "\r\n";
    response = response + body;
    
    return response;
}

// ============================================
// Cookie Handling
// ============================================

// Cookie Parse Et
// "name=value; name2=value2" -> {"name": "value", "name2": "value2"}
func parse_cookies(str cookie_header) {
    json cookies = {};
    
    if (length(cookie_header) == 0) {
        return cookies;
    }
    
    array parts = split(cookie_header, ";");
    
    for (int i = 0; i < length(parts); i++) {
        str part = parts[i];
        // Trim whitespace (basit implementasyon)
        // TODO: string_trim fonksiyonu eklendiğinde güncelle
        
        array kv = split(part, "=");
        if (length(kv) >= 2) {
            str key = kv[0];
            str val = kv[1];
            
            // Key başındaki boşlukları temizle (basit)
            if (length(key) > 0 && key[0] == " ") {
                key = substring(key, 1, length(key));
            }
            
            cookies[key] = val;
        }
    }
    
    return cookies;
}

// Set-Cookie Header Oluştur
func create_cookie(str name, str value, json options) {
    str cookie = name + "=" + value;
    
    if (options["Path"]) {
        cookie = cookie + "; Path=" + options["Path"];
    } else {
        cookie = cookie + "; Path=/";
    }
    
    if (options["HttpOnly"]) {
        if (options["HttpOnly"]) {
            cookie = cookie + "; HttpOnly";
        }
    }
    
    if (options["Secure"]) {
        if (options["Secure"]) {
            cookie = cookie + "; Secure";
        }
    }
    
    if (options["Max-Age"]) {
        cookie = cookie + "; Max-Age=" + toString(options["Max-Age"]);
    }
    
    if (options["SameSite"]) {
        cookie = cookie + "; SameSite=" + options["SameSite"];
    }
    
    return cookie;
}

// ============================================
// Session Management (In-Memory)
// ============================================

json _sessions = {};

// Yeni session oluştur
func create_session(json user_data) {
    // Basit session ID oluşturma (random sayı + timestamp)
    // Not: Gerçek uygulamada daha güvenli UUID kullanılmalı
    int rand_id = 0; // TODO: random() eklenince güncelle
    str session_id = "sess_" + toString(_router_port) + "_" + toString(length(_sessions)); 
    
    _sessions[session_id] = {
        "id": session_id,
        "data": user_data,
        "created_at": "TODO: timestamp", 
        "expires_at": "TODO: timestamp + duration"
    };
    
    return session_id;
}

// Session getir
func get_session(str session_id) {
    if (_sessions[session_id]) {
        return _sessions[session_id];
    }
    return {};
}

// Session sil
func destroy_session(str session_id) {
    // Tulpar'da array/map elemanı silme desteği kısıtlı olabilir
    // Şimdilik boşaltma yapalım
    if (_sessions[session_id]) {
        _sessions[session_id] = {}; 
        return true;
    }
    return false;
}

// ============================================
// Static File Serving
// ============================================

// Content-Type belirle
func get_mime_type(str filename) {
    if (endsWith(filename, ".html")) { return "text/html"; }
    if (endsWith(filename, ".css")) { return "text/css"; }
    if (endsWith(filename, ".js")) { return "application/javascript"; }
    if (endsWith(filename, ".json")) { return "application/json"; }
    if (endsWith(filename, ".png")) { return "image/png"; }
    if (endsWith(filename, ".jpg")) { return "image/jpeg"; }
    if (endsWith(filename, ".txt")) { return "text/plain"; }
    return "application/octet-stream";
}

// Dosya oku ve response hazırla
// Not: read_file fonksiyonu interpreter'da olmalı
func serve_static_file(str path) {
    // Path traversal koruması (basit)
    if (contains(path, "..")) {
        return json_response(403, {"error": "Forbidden"});
    }
    
    try {
        // Dosya okuma (Interpreter'da read_file built-in olmalı)
        // Eğer yoksa, bu fonksiyonu interpreter güncellemesinden sonra aktifleştirin
        // şimdilik simülasyon
        
        // str content = read_file(path); // TODO: implement read_file
        // return http_create_response(200, get_mime_type(path), content);
        
        return json_response(501, {"error": "Not Implemented: File IO pending"});
        
    } catch (e) {
        return json_response(404, {"error": "File not found"});
    }
}
